// ==========================================
// Service Worker para PWA Mapa de Puerres
// ==========================================

const CACHE_NAME = 'puerres-map-v1-' + Date.now();
const RUNTIME_CACHE = 'puerres-runtime-v1-' + Date.now();

// Archivos cr√≠ticos para precachear
const PRECACHE_URLS = [
    '/',
    '/index.html',
    '/css/style.css',
    '/js/app.js',
    '/js/map.js',
    '/manifest.json',
    '/icons/icon-192x192.png',
    '/icons/icon-512x512.png'
];

// Recursos externos cr√≠ticos
const EXTERNAL_CACHE = [
    'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
    'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js',
    'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css'
];

// ==========================================
// Evento de Instalaci√≥n
// ==========================================
self.addEventListener('install', (event) => {
    console.log('üîß Service Worker: Instalando...');
    
    event.waitUntil(
        Promise.resolve().then(() => {
            console.log('‚úÖ Service Worker: Instalaci√≥n completada (MODO DESARROLLO)');
        })
    );
    
    // Forzar activaci√≥n inmediata
    self.skipWaiting();
});

// ==========================================
// Evento de Activaci√≥n
// ==========================================
self.addEventListener('activate', (event) => {
    console.log('üöÄ Service Worker: Activando...');
    
    event.waitUntil(
        Promise.all([
            // Limpiar cach√©s antiguos
            caches.keys().then(cacheNames => {
                return Promise.all(
                    cacheNames.map(cacheName => {
                        console.log('üóëÔ∏è Eliminando cach√©:', cacheName);
                        return caches.delete(cacheName);
                    })
                );
            }),
            
            // Tomar control de todos los clientes
            self.clients.claim()
        ]).then(() => {
            console.log('‚úÖ Service Worker: Activaci√≥n completada');
            
            // Notificar a los clientes que hay una nueva versi√≥n
            self.clients.matchAll().then(clients => {
                clients.forEach(client => {
                    client.postMessage({ type: 'SW_UPDATED' });
                });
            });
        })
    );
});

// ==========================================
// Evento de Fetch
// ==========================================
self.addEventListener('fetch', (event) => {
    const url = new URL(event.request.url);
    
    // Solo manejar requests HTTP/HTTPS
    if (!event.request.url.startsWith('http')) {
        return;
    }
    
    // Estrategia para archivos locales
    if (isLocalFile(url)) {
        event.respondWith(alwaysNetworkFirst(event.request));
        return;
    }
    
    // Estrategia para recursos externos
    if (isExternalResource(url)) {
        event.respondWith(networkFirstWithFallback(event.request));
        return;
    }
    
    // Para otros recursos, usar estrategia de red
    event.respondWith(fetch(event.request));
});

// ==========================================
// Estrategias de Cach√©
// ==========================================

// Estrategia: Siempre red primero (para archivos locales en desarrollo)
async function alwaysNetworkFirst(request) {
    try {
        console.log('üåê Intentando red para:', request.url);
        
        // Crear request con headers anti-cach√©
        const networkRequest = new Request(request.url, {
            method: request.method,
            headers: {
                ...request.headers,
                'Cache-Control': 'no-store, no-cache, must-revalidate',
                'Pragma': 'no-cache',
                'Expires': '0'
            }
        });
        
        const response = await fetch(networkRequest, {
            cache: 'no-store'
        });
        
        if (response.ok) {
            console.log('‚úÖ Respuesta exitosa de red:', request.url);
            return response;
        } else {
            throw new Error(`HTTP ${response.status}`);
        }
        
    } catch (error) {
        console.log('‚ùå Error de red, intentando cach√©:', request.url, error.message);
        
        // Intentar desde cach√© como √∫ltimo recurso
        const cachedResponse = await caches.match(request);
        if (cachedResponse) {
            console.log('üì¶ Sirviendo desde cach√©:', request.url);
            return cachedResponse;
        }
        
        // Si no hay cach√©, devolver error
        console.log('üí• No se pudo obtener recurso:', request.url);
        return new Response('Recurso no disponible offline', {
            status: 503,
            statusText: 'Service Unavailable'
        });
    }
}

// Estrategia: Red primero con fallback a cach√©
async function networkFirstWithFallback(request) {
    try {
        console.log('üåê Intentando red para recurso externo:', request.url);
        
        // Agregar timestamp para evitar cach√© del navegador
        const urlWithTimestamp = new URL(request.url);
        urlWithTimestamp.searchParams.set('v', Date.now());
        
        const response = await fetch(urlWithTimestamp, {
            cache: 'no-cache',
            headers: {
                'Cache-Control': 'no-store, no-cache, must-revalidate',
                'Pragma': 'no-cache',
                'Expires': '0'
            }
        });
        
        if (response.ok) {
            console.log('‚úÖ Recurso externo obtenido:', request.url);
            
            // Guardar en cach√© para uso offline
            const cache = await caches.open(RUNTIME_CACHE);
            cache.put(request, response.clone());
            
            return response;
        } else {
            throw new Error(`HTTP ${response.status}`);
        }
        
    } catch (error) {
        console.log('‚ùå Error de red para recurso externo:', request.url);
        
        // Intentar desde cach√©
        const cachedResponse = await caches.match(request);
        if (cachedResponse) {
            console.log('üì¶ Sirviendo recurso externo desde cach√©:', request.url);
            return cachedResponse;
        }
        
        // Fallback gen√©rico
        console.log('üí• Recurso externo no disponible:', request.url);
        return new Response('Recurso externo no disponible', {
            status: 503,
            statusText: 'Service Unavailable'
        });
    }
}

// ==========================================
// Utilidades
// ==========================================

// Verificar si es un archivo local
function isLocalFile(url) {
    return url.hostname === self.location.hostname || 
           url.hostname === 'localhost' ||
           url.protocol === 'file:';
}

// Verificar si es un recurso externo cr√≠tico
function isExternalResource(url) {
    const externalHosts = [
        'unpkg.com',
        'cdnjs.cloudflare.com',
        'tile.openstreetmap.org',
        'server.arcgisonline.com',
        'basemaps.cartocdn.com'
    ];
    
    return externalHosts.some(host => url.hostname.includes(host));
}

// ==========================================
// Manejo de Mensajes
// ==========================================
self.addEventListener('message', (event) => {
    const { type, payload } = event.data;
    
    switch (type) {
        case 'SKIP_WAITING':
            console.log('üîÑ Saltando espera del Service Worker');
            self.skipWaiting();
            break;
            
        case 'CLEAR_CACHE':
            console.log('üóëÔ∏è Limpiando cach√© por solicitud');
            clearAllCaches();
            break;
            
        case 'GET_CACHE_STATUS':
            console.log('üìä Enviando estado del cach√©');
            getCacheStatus().then(status => {
                event.ports[0].postMessage({ type: 'CACHE_STATUS', payload: status });
            });
            break;
            
        default:
            console.log('‚ùì Mensaje desconocido:', type);
    }
});

// ==========================================
// Funciones de Utilidad para Mensajes
// ==========================================

async function clearAllCaches() {
    try {
        const cacheNames = await caches.keys();
        await Promise.all(
            cacheNames.map(cacheName => caches.delete(cacheName))
        );
        console.log('‚úÖ Todos los cach√©s limpiados');
    } catch (error) {
        console.error('‚ùå Error limpiando cach√©s:', error);
    }
}

async function getCacheStatus() {
    try {
        const cacheNames = await caches.keys();
        const status = {
            cacheCount: cacheNames.length,
            cacheNames: cacheNames,
            timestamp: Date.now()
        };
        
        // Obtener tama√±o aproximado de cada cach√©
        for (const cacheName of cacheNames) {
            const cache = await caches.open(cacheName);
            const keys = await cache.keys();
            status[cacheName] = {
                keyCount: keys.length,
                urls: keys.map(request => request.url)
            };
        }
        
        return status;
    } catch (error) {
        console.error('‚ùå Error obteniendo estado del cach√©:', error);
        return { error: error.message };
    }
}

// ==========================================
// Manejo de Errores
// ==========================================
self.addEventListener('error', (event) => {
    console.error('‚ùå Error en Service Worker:', event.error);
});

self.addEventListener('unhandledrejection', (event) => {
    console.error('‚ùå Promise rechazada en Service Worker:', event.reason);
});

// ==========================================
// Notificaciones Push (Preparado para futuro)
// ==========================================
self.addEventListener('push', (event) => {
    if (event.data) {
        const data = event.data.json();
        
        const options = {
            body: data.body,
            icon: '/icons/icon-192x192.png',
            badge: '/icons/icon-96x96.png',
            vibrate: [100, 50, 100],
            data: data.data,
            actions: [
                {
                    action: 'explore',
                    title: 'Ver en el mapa',
                    icon: '/icons/icon-96x96.png'
                },
                {
                    action: 'close',
                    title: 'Cerrar',
                    icon: '/icons/icon-96x96.png'
                }
            ]
        };
        
        event.waitUntil(
            self.registration.showNotification(data.title, options)
        );
    }
});

// ==========================================
// Manejo de Clics en Notificaciones
// ==========================================
self.addEventListener('notificationclick', (event) => {
    event.notification.close();
    
    if (event.action === 'explore') {
        event.waitUntil(
            clients.openWindow('/')
        );
    }
});

// ==========================================
// Log de Inicializaci√≥n
// ==========================================
console.log('üöÄ Service Worker iniciado - Mapa de Puerres');
console.log('üìÖ Versi√≥n:', CACHE_NAME);
console.log('üåê Modo:', 'DESARROLLO');
console.log('‚ö° Estrategia: Red Primero');
